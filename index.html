<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Virtual Room</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 100;
            border: 2px solid #00ff00;
        }
        
        #controls h2 {
            margin-bottom: 10px;
            font-size: 16px;
            text-transform: uppercase;
        }
        
        #controls p {
            margin: 5px 0;
        }
        
        .control-item {
            margin: 8px 0;
        }
        
        .key {
            background: #00ff00;
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            display: inline-block;
            min-width: 30px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h2>Virtual Room</h2>
        <div class="control-item">
            <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> - Move Forward/Left/Back/Right
        </div>
        <div class="control-item">
            <span class="key">Space</span> / <span class="key">Shift</span> - Move Up/Down
        </div>
        <div class="control-item">
            <span class="key">Mouse</span> - Look Around
        </div>
        <div class="control-item">
            <span class="key">R</span> - Reset Cube Position
        </div>
        <p id="cubePos" style="margin-top: 15px;">Cube Position: X: 0 Y: 0 Z: 0</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.Fog(0x1a1a1a, 50, 100);

        // Camera
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 2, 5);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        scene.add(directionalLight);

        // Create virtual room (walls, floor, ceiling)
        const roomSize = 40;
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a4a4a,
            roughness: 0.8,
            metalness: 0.1
        });

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.9,
            metalness: 0
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Ceiling
        const ceiling = new THREE.Mesh(floorGeometry, wallMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = 10;
        ceiling.receiveShadow = true;
        scene.add(ceiling);

        // Back wall
        const wallGeometry = new THREE.PlaneGeometry(roomSize, 10);
        const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
        backWall.position.z = -roomSize / 2;
        backWall.position.y = 5;
        backWall.receiveShadow = true;
        scene.add(backWall);

        // Front wall
        const frontWall = new THREE.Mesh(wallGeometry, wallMaterial);
        frontWall.position.z = roomSize / 2;
        frontWall.position.y = 5;
        frontWall.rotation.y = Math.PI;
        frontWall.receiveShadow = true;
        scene.add(frontWall);

        // Left wall
        const sideWallGeometry = new THREE.PlaneGeometry(roomSize, 10);
        const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
        leftWall.position.x = -roomSize / 2;
        leftWall.position.y = 5;
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        // Right wall
        const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
        rightWall.position.x = roomSize / 2;
        rightWall.position.y = 5;
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        // Create movable cube
        const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
        const cubeMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            roughness: 0.4,
            metalness: 0.6,
            emissive: 0x00aa00
        });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(0, 1, 0);
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);

        // Create some decorative elements
        const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const sphereMaterial = new THREE.MeshStandardMaterial({
            color: 0xff6600,
            roughness: 0.3,
            metalness: 0.7
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(8, 1, -8);
        sphere.castShadow = true;
        sphere.receiveShadow = true;
        scene.add(sphere);

        const cylinderGeometry = new THREE.CylinderGeometry(0.4, 0.4, 2, 32);
        const cylinderMaterial = new THREE.MeshStandardMaterial({
            color: 0x0066ff,
            roughness: 0.4,
            metalness: 0.5
        });
        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        cylinder.position.set(-8, 1, 8);
        cylinder.castShadow = true;
        cylinder.receiveShadow = true;
        scene.add(cylinder);

        // Movement control
        const keys = {};
        const cubeSpeed = 0.1;
        const cubeInitialPos = { x: 0, y: 1, z: 0 };

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key.toLowerCase() === 'r') {
                cube.position.set(cubeInitialPos.x, cubeInitialPos.y, cubeInitialPos.z);
                cube.rotation.set(0, 0, 0);
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse look control
        const lookSpeed = 0.003;
        let isPointerLocked = false;
        let cameraYaw = 0;
        let cameraPitch = 0;

        document.addEventListener('click', () => {
            document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
            document.body.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === document.body;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked) return;

            cameraYaw -= e.movementX * lookSpeed;
            cameraPitch -= e.movementY * lookSpeed;

            // Clamp pitch
            cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation and update loop
        function animate() {
            requestAnimationFrame(animate);

            // Move cube based on keyboard input
            if (keys['w']) cube.position.z -= cubeSpeed;
            if (keys['s']) cube.position.z += cubeSpeed;
            if (keys['a']) cube.position.x -= cubeSpeed;
            if (keys['d']) cube.position.x += cubeSpeed;
            if (keys[' ']) cube.position.y += cubeSpeed;
            if (keys['shift']) cube.position.y -= cubeSpeed;

            // Keep cube within room bounds
            const boundary = 19;
            cube.position.x = Math.max(-boundary, Math.min(boundary, cube.position.x));
            cube.position.z = Math.max(-boundary, Math.min(boundary, cube.position.z));
            cube.position.y = Math.max(0.5, Math.min(9, cube.position.y));

            // Rotate cube
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.015;

            // Update position display
            document.getElementById('cubePos').textContent = 
                `Cube Position: X: ${cube.position.x.toFixed(2)} Y: ${cube.position.y.toFixed(2)} Z: ${cube.position.z.toFixed(2)}`;

            // Update camera rotation based on mouse look
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraYaw;
            camera.rotation.x = cameraPitch;

            // Position camera at cube + offset
            const cameraOffset = 2.5;
            camera.position.x = cube.position.x;
            camera.position.y = cube.position.y + 0.8;
            camera.position.z = cube.position.z + cameraOffset;

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
