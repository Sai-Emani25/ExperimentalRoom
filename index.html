<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Virtual Room</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 100;
            border: 2px solid #00ff00;
        }
        
        #controls h2 {
            margin-bottom: 10px;
            font-size: 16px;
            text-transform: uppercase;
        }
        
        #controls p {
            margin: 5px 0;
        }
        
        .control-item {
            margin: 8px 0;
        }
        
        .key {
            background: #00ff00;
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            display: inline-block;
            min-width: 30px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h2>Virtual Room</h2>
        <div class="control-item">
            <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> - Move Forward/Left/Back/Right
        </div>
        <div class="control-item">
            <span class="key">Mouse</span> - Look Around
        </div>
        <div class="control-item">
            <span class="key">Space</span> - Jump
        </div>
        <div class="control-item">
            <span class="key">R</span> - Reset Cube Position
        </div>
        <p id="cubePos" style="margin-top: 15px;">Cube Position: X: 0 Y: 0 Z: 0</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.Fog(0x1a1a1a, 50, 100);

        // Camera
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 2, 5);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        scene.add(directionalLight);

        // Create virtual room (walls, floor, ceiling)
        const roomSize = 40;
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a4a4a,
            roughness: 0.8,
            metalness: 0.1
        });

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.9,
            metalness: 0
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Ceiling
        const ceiling = new THREE.Mesh(floorGeometry, wallMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = 10;
        ceiling.receiveShadow = true;
        scene.add(ceiling);

        // Back wall
        const wallGeometry = new THREE.PlaneGeometry(roomSize, 10);
        const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
        backWall.position.z = -roomSize / 2;
        backWall.position.y = 5;
        backWall.receiveShadow = true;
        scene.add(backWall);

        // Front wall
        const frontWall = new THREE.Mesh(wallGeometry, wallMaterial);
        frontWall.position.z = roomSize / 2;
        frontWall.position.y = 5;
        frontWall.rotation.y = Math.PI;
        frontWall.receiveShadow = true;
        scene.add(frontWall);

        // Left wall
        const sideWallGeometry = new THREE.PlaneGeometry(roomSize, 10);
        const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
        leftWall.position.x = -roomSize / 2;
        leftWall.position.y = 5;
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        // Right wall
        const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
        rightWall.position.x = roomSize / 2;
        rightWall.position.y = 5;
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        // Create movable cube
        const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
        const cubeMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            roughness: 0.4,
            metalness: 0.6,
            emissive: 0x00aa00
        });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(0, 1, 0);
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);

        // Create some decorative elements
        const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const sphereMaterial = new THREE.MeshStandardMaterial({
            color: 0xff6600,
            roughness: 0.3,
            metalness: 0.7
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(8, 1, -8);
        sphere.castShadow = true;
        sphere.receiveShadow = true;
        scene.add(sphere);

        const cylinderGeometry = new THREE.CylinderGeometry(0.4, 0.4, 2, 32);
        const cylinderMaterial = new THREE.MeshStandardMaterial({
            color: 0x0066ff,
            roughness: 0.4,
            metalness: 0.5
        });
        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        cylinder.position.set(-8, 1, 8);
        cylinder.castShadow = true;
        cylinder.receiveShadow = true;
        scene.add(cylinder);

        // Create floating platform
        const platformGeometry = new THREE.BoxGeometry(4, 0.5, 4);
        const platformMaterial = new THREE.MeshStandardMaterial({
            color: 0x9933ff,
            roughness: 0.5,
            metalness: 0.3
        });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.set(12, 2, 12);
        platform.castShadow = true;
        platform.receiveShadow = true;
        scene.add(platform);

        // Create multiple cubes scattered around
        const smallCubeGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
        const colors = [0xffff00, 0xff00ff, 0x00ffff, 0xff0000];
        const cubePositions = [
            { x: -10, y: 1, z: 0 },
            { x: 0, y: 1, z: 10 },
            { x: 10, y: 1, z: -10 },
            { x: -12, y: 1, z: -12 }
        ];

        cubePositions.forEach((pos, idx) => {
            const smallCubeMaterial = new THREE.MeshStandardMaterial({
                color: colors[idx],
                roughness: 0.5,
                metalness: 0.4,
                emissive: colors[idx],
                emissiveIntensity: 0.3
            });
            const smallCube = new THREE.Mesh(smallCubeGeometry, smallCubeMaterial);
            smallCube.position.set(pos.x, pos.y, pos.z);
            smallCube.castShadow = true;
            smallCube.receiveShadow = true;
            scene.add(smallCube);
        });

        // Create pyramids (cones)
        const coneGeometry = new THREE.ConeGeometry(0.6, 1.5, 8);
        const coneMaterial = new THREE.MeshStandardMaterial({
            color: 0x00aa00,
            roughness: 0.6,
            metalness: 0.2
        });
        const cone1 = new THREE.Mesh(coneGeometry, coneMaterial);
        cone1.position.set(5, 0.8, -15);
        cone1.castShadow = true;
        cone1.receiveShadow = true;
        scene.add(cone1);

        const cone2 = new THREE.Mesh(coneGeometry, coneMaterial);
        cone2.position.set(-15, 0.8, 5);
        cone2.castShadow = true;
        cone2.receiveShadow = true;
        scene.add(cone2);

        // Create torus for decoration
        const torusGeometry = new THREE.TorusGeometry(1.5, 0.4, 16, 100);
        const torusMaterial = new THREE.MeshStandardMaterial({
            color: 0xffaa00,
            roughness: 0.3,
            metalness: 0.8
        });
        const torus = new THREE.Mesh(torusGeometry, torusMaterial);
        torus.position.set(0, 3, 0);
        torus.rotation.x = Math.PI / 4;
        torus.castShadow = true;
        torus.receiveShadow = true;
        scene.add(torus);

        // Create boxes stacked together
        const stackBoxGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const stackMaterial = new THREE.MeshStandardMaterial({
            color: 0xaa0066,
            roughness: 0.7,
            metalness: 0.2
        });
        
        for (let i = 0; i < 3; i++) {
            const stackBox = new THREE.Mesh(stackBoxGeometry, stackMaterial);
            stackBox.position.set(-15, 0.4 + i * 0.8, -15);
            stackBox.castShadow = true;
            stackBox.receiveShadow = true;
            scene.add(stackBox);
        }

        // Movement control
        const keys = {};
        const cubeSpeed = 0.1;
        const cubeInitialPos = { x: 0, y: 1, z: 0 };
        
        // Physics/Gravity
        const gravity = 0.75; // 5g force for jump landing
        const jumpForce = 1.6; // Stronger jump impulse so it visibly lifts before gravity pulls down
        const cubeVelocity = { x: 0, y: 0, z: 0 };
        const groundLevel = 0.5;
        let isGrounded = true;
        let canJump = true;

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            const key = e.key.toLowerCase();
            
            if (key === 'r') {
                cube.position.set(cubeInitialPos.x, cubeInitialPos.y, cubeInitialPos.z);
                cube.rotation.set(0, 0, 0);
                cubeVelocity.y = 0;
                isGrounded = true;
                canJump = true;
            }
            // Jump mechanic
            if (key === ' ' && isGrounded && canJump) {
                cubeVelocity.y = jumpForce;
                isGrounded = false;
                canJump = false;
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse look control - Third person camera
        const lookSpeed = 0.005;
        let isPointerLocked = false;
        let cameraYaw = 0;
        let cameraPitch = Math.PI / 6; // 30 degrees angle
        const cameraDistance = 6;

        document.addEventListener('click', () => {
            document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
            document.body.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === document.body;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked) return;

            cameraYaw -= e.movementX * lookSpeed;
            cameraPitch -= e.movementY * lookSpeed;

            // Clamp pitch to prevent flipping
            cameraPitch = Math.max(Math.PI / 12, Math.min(Math.PI / 2.5, cameraPitch));
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation and update loop
        function animate() {
            requestAnimationFrame(animate);

            // Calculate movement direction based on camera angle
            const moveVector = new THREE.Vector3(0, 0, 0);
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            
            forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);
            right.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);

            // Character movement based on keyboard input
            if (keys['w']) moveVector.add(forward);
            if (keys['s']) moveVector.sub(forward);
            if (keys['a']) moveVector.sub(right);
            if (keys['d']) moveVector.add(right);

            // Normalize and apply speed
            if (moveVector.length() > 0) {
                moveVector.normalize();
                cubeVelocity.x = moveVector.x * cubeSpeed;
                cubeVelocity.z = moveVector.z * cubeSpeed;
            } else {
                cubeVelocity.x = 0;
                cubeVelocity.z = 0;
            }

            // Apply gravity
            cubeVelocity.y -= gravity;
            
            // Apply velocity
            cube.position.x += cubeVelocity.x;
            cube.position.y += cubeVelocity.y;
            cube.position.z += cubeVelocity.z;

            // Check collision with ground
            if (cube.position.y <= groundLevel) {
                cube.position.y = groundLevel;
                cubeVelocity.y = 0;
                isGrounded = true;
                canJump = true;
            } else {
                isGrounded = false;
            }

            // Keep cube within room bounds
            const boundary = 19;
            cube.position.x = Math.max(-boundary, Math.min(boundary, cube.position.x));
            cube.position.z = Math.max(-boundary, Math.min(boundary, cube.position.z));
            cube.position.y = Math.max(groundLevel, Math.min(9, cube.position.y));

            // Rotate cube based on movement direction
            if (moveVector.length() > 0) {
                const targetYaw = Math.atan2(moveVector.x, moveVector.z);
                cube.rotation.y = targetYaw;
            }
            
            // Slight bobbing animation
            cube.rotation.x = Math.sin(Date.now() * 0.001) * 0.1;

            // Update position display
            document.getElementById('cubePos').textContent = 
                `Cube Position: X: ${cube.position.x.toFixed(2)} Y: ${cube.position.y.toFixed(2)} Z: ${cube.position.z.toFixed(2)}`;

            // Third person camera positioning (Fortnite style)
            const cameraHeight = 1.5;
            const horizontalDistance = cameraDistance * Math.cos(cameraPitch);
            const verticalDistance = cameraDistance * Math.sin(cameraPitch);
            
            camera.position.x = cube.position.x + Math.sin(cameraYaw) * horizontalDistance;
            camera.position.y = cube.position.y + cameraHeight + verticalDistance;
            camera.position.z = cube.position.z + Math.cos(cameraYaw) * horizontalDistance;
            
            // Make camera look at cube
            camera.lookAt(cube.position.x, cube.position.y + 0.5, cube.position.z);

            // Animate decorative objects
            torus.rotation.z += 0.005;
            torus.rotation.y += 0.003;

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>